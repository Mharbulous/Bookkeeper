<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File Deduplication</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .container {
            max-width: 900px;
        }
        .code-block {
            background-color: #1f2937;
            color: #d1d5db;
        }
        .drop-zone {
            border: 4px dashed #9ca3af;
            background-color: #f9fafb;
            transition: all 0.3s ease;
        }
        .drop-zone.dragover {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="container bg-white shadow-xl rounded-2xl p-8 space-y-8">
        <!-- Title and Description -->
        <header class="text-center">
            <h1 class="text-3xl font-bold text-gray-900 mb-2">File Deduplication with Maps</h1>
            <p class="text-gray-600">
                Drag and drop files or a folder to see how nested Maps can be used to deduplicate based on file content.
            </p>
        </header>

        <!-- Drop Zone and Control Panel -->
        <section class="bg-gray-50 rounded-xl p-6 border border-gray-200 space-y-4">
            <div id="dropZone" class="drop-zone flex flex-col items-center justify-center p-12 rounded-xl text-gray-500">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mb-2 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M7 16a4 4 0 01-.882-.047M15 12a3 3 0 013 3v2a1 1 0 001 1h2a1 1 0 001-1v-2a4 4 0 00-4-4h-2a4 4 0 00-4-4V7a4 4 0 014-4h2a4 4 0 014 4v1m-9 3h.01M5 16h.01M21 16h.01" />
                </svg>
                <p class="text-lg font-medium">Drag files or a folder here</p>
                <p class="text-sm">Release to upload</p>
            </div>
        </section>

        <!-- Status and Output -->
        <section class="space-y-4">
            <div id="messageBox" class="text-center text-sm font-medium py-3 rounded-lg hidden transition-opacity duration-300"></div>
            
            <div class="space-y-2">
                <h2 class="text-xl font-semibold text-gray-800">Resulting Data Structure</h2>
                <div class="code-block rounded-xl p-4 overflow-x-auto">
                    <pre id="outputPre" class="text-sm"></pre>
                </div>
            </div>

            <div class="space-y-2">
                <h2 class="text-xl font-semibold text-gray-800">Files Processed</h2>
                <div class="bg-gray-50 rounded-xl p-4 border border-gray-200">
                    <ul id="fileList" class="space-y-2 text-sm text-gray-700"></ul>
                </div>
            </div>
        </section>
    </div>

    <script>
        // Initialize the root Map for file sizes.
        const fileSizesMap = new Map();

        // DOM elements
        const dropZone = document.getElementById('dropZone');
        const outputPre = document.getElementById('outputPre');
        const messageBox = document.getElementById('messageBox');
        const fileList = document.getElementById('fileList');

        // Main function to process a dropped file or directory entry.
        async function processEntry(entry) {
            // Check if it's a directory
            if (entry.isDirectory) {
                // If so, get a reader for the directory.
                const reader = entry.createReader();
                
                // Use a promise to read all entries in the directory.
                const readAllEntries = () => new Promise(resolve => {
                    const entries = [];
                    const readEntries = () => {
                        reader.readEntries(items => {
                            if (items.length === 0) {
                                resolve(entries);
                            } else {
                                entries.push(...items);
                                readEntries();
                            }
                        });
                    };
                    readEntries();
                });
                
                const entries = await readAllEntries();
                for (const subEntry of entries) {
                    // Recursively process each entry in the directory.
                    await processEntry(subEntry);
                }
            } else if (entry.isFile) {
                // If it's a file, get the File object.
                const file = await new Promise(resolve => entry.file(resolve));
                // Call the function to handle the file and add it to our map.
                await handleFile(file);
            }
        }

        // Function to handle a single File object.
        async function handleFile(file) {
            // Get file metadata.
            const fileSize = file.size;
            const fileName = file.name;
            const created = new Date(file.lastModified).toISOString(); // Approximate created date
            const modified = new Date(file.lastModified).toISOString();

            showMessage(`Processing "${fileName}"...`, "bg-blue-200 text-blue-800");
            
            try {
                // Create a SHA-256 hash of the file content.
                const arrayBuffer = await file.arrayBuffer();
                const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                // The main function to add a file and handle deduplication.
                const isDeduplicated = addFile(hashHex, fileSize, fileName, created, modified, file.name);

                // Add the file to the list on the UI.
                const listItem = document.createElement('li');
                listItem.className = 'py-1 flex justify-between items-center';
                const statusSpan = document.createElement('span');
                
                if (isDeduplicated) {
                    statusSpan.textContent = 'Deduplicated';
                    statusSpan.className = 'text-green-500 font-semibold';
                } else {
                    statusSpan.textContent = 'Added';
                    statusSpan.className = 'text-blue-500 font-semibold';
                }

                listItem.innerHTML = `<span class="truncate">${file.name}</span>`;
                listItem.appendChild(statusSpan);
                fileList.appendChild(listItem);
                
                // Display the updated data structure.
                displayMaps();
                
                showMessage(`File "${fileName}" processed successfully.`, "bg-green-500 text-white");
            } catch (error) {
                showMessage(`Error processing "${fileName}": ${error.message}`, "bg-red-500 text-white");
            }
        }

        // This is the core function that builds and populates the nested Map structure.
        function addFile(hash, fileSize, fileName, created, modified, reference) {
            // This function returns true if the file was a duplicate, false otherwise.
            let isDuplicate = false;

            // Check if the fileSize exists in the top-level map.
            if (!fileSizesMap.has(fileSize)) {
                fileSizesMap.set(fileSize, new Map());
            }

            // Get the next level map (file names).
            const fileNamesMap = fileSizesMap.get(fileSize);

            if (!fileNamesMap.has(fileName)) {
                fileNamesMap.set(fileName, new Map());
            }

            // Get the next level map (creation dates).
            const createdDatesMap = fileNamesMap.get(fileName);

            if (!createdDatesMap.has(created)) {
                createdDatesMap.set(created, new Map());
            }

            // Get the next level map (modification dates).
            const modifiedDatesMap = createdDatesMap.get(created);

            // Check if the file with this hash already exists.
            if (modifiedDatesMap.has(hash)) {
                isDuplicate = true;
            }

            // This is the final level. We use the hash as the key.
            // If the hash already exists, the value will be updated, effectively deduplicating.
            modifiedDatesMap.set(hash, {
                fileReference: reference,
                modified: modified
            });
            
            return isDuplicate;
        }

        // Function to display the nested Maps in a readable format
        function displayMaps() {
            const mapToObject = (map) => {
                const obj = {};
                for (let [key, value] of map) {
                    if (value instanceof Map) {
                        obj[key] = mapToObject(value);
                    } else {
                        obj[key] = value;
                    }
                }
                return obj;
            };
            const objRepresentation = mapToObject(fileSizesMap);
            outputPre.textContent = JSON.stringify(objRepresentation, null, 2);
        }

        // Function to show a temporary message in the message box
        function showMessage(message, classes) {
            messageBox.textContent = message;
            messageBox.className = `text-center text-sm font-medium py-3 rounded-lg ${classes}`;
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, 5000);
        }

        // --- Drag and Drop Event Listeners ---
        dropZone.addEventListener('dragover', (event) => {
            event.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', (event) => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', async (event) => {
            event.preventDefault();
            dropZone.classList.remove('dragover');
            fileList.innerHTML = '';
            
            // Iterate over each dropped item.
            for (let i = 0; i < event.dataTransfer.items.length; i++) {
                const item = event.dataTransfer.items[i];
                const entry = item.webkitGetAsEntry();
                if (entry) {
                    await processEntry(entry);
                }
            }
        });
    </script>

</body>
</html>
